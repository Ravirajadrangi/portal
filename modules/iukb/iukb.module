<?php
// vim: filetype=php
// Author: Matthew Lewallen
// Contact: mlewalle [at] indiana edu -or- mithril293 [at] gmail com

/**
 * @file
 * This module provides several menu callbacks (all beginning with /kb/) and
 * an optional input filter that implement theming kb.iu.edu articles through
 * the local site's theme.
 */
define("IUKB_API_USER", "fgrid");
define("IUKB_API_KEY", "OV93R7JNO0");
define("IUKB_KB", "futuregrid");
define("IUKB_AUDIENCE", "fgrid");
define("IUKB_RESULTS_PER_PAGE", "10");
define("IUKB_SOAP_URL", "http://remote.kb.iu.edu/SOAP/v0.2/kb.wsdl");
define("IUKB_REST_URL", "https://remote.kb.iu.edu/REST/v0.2/");

/**
 * Sub: iukb_help
 * Purpose: Implementation of hook_help
 */

function iukb_help($section) {
	switch ($section) {
		case 'admin/help#iukb':
			return t('<p>The iukb module provides a menu callback to bring content from the IU KB and format it with the current site\'s theme.</p><p>There is also an input filter that will automaticall map a href links from kb.iu.edu to the local site\'s rendering of the page and for a convenience [iukb] link encoding.');
	}
}

/**
 * Sub: iukb_node_info
 * Purpose: Implementation of iukb_node_info
 */

function iukb_node_info() {
	return array(
		'iukb' => array(
			'name' => t('Knowledge base'),
			'module' => 'iukb',
			'description' => 'Represents a KnowledgeBase document.'
		)
	);
}

/**
 * Sub: iukb_menu
 * Purpose: Implements iukb_menu and defines 3 menu callbacks:
 * kb/%, kb/search/%, kb/search/%/%
 */

function iukb_menu() {

	// Initial search
	$items['kb'] = array(
		'title' => 'Knowledge Base Search',
		'page callback' => 'iukb_search_redirect',
		'access arguments' => array('access iukb'),
		'type' => MENU_CALLBACK,
	);
	$items['kb/index'] = array(
		'title' => 'Knowledge Base Document Index',
		'page callback' => 'iukb_document_list',
		'access arguments' => array('access iukb'),
		'type' => MENU_CALLBACK,
	);
	
	// kb article
	$items['kb/document/%'] = array(
		'title' => 'Knowledge Base',
		'page callback' => 'iukb_soap_lookup',
		'page arguments' => array(2),
		'access arguments' => array('access iukb'),
		'type' => MENU_CALLBACK,
	);
	
	// admin
	$items['admin/settings/iukb'] = array(
		'title' => 'IU Knowledge Base Configuration'
	);
	return $items;
}

/**
 * Sub: iukb_perm
 * Purpose: Implements hook_perm
 * Note: administer iukb isn't yet used
 */

function iukb_perm() {
  return array('administer iukb', 'access iukb');
}

/**
 * Sub: iukb_filter_tips
 * Purpose: implements hook_filter_tips, but I'm not sure what it does yet (:
 */

function iukb_filter_tips($delta, $format, $long = FALSE) {
	switch ($delta) {
		case 0:
			if ($long) return t(
				'This filter searches node content for &lt;a&lt; links to ' .
				'kb.iu.edu and rewrites them to local /kb/ entries which ' .
				'display the same content. It can also replace quick kb links ' .
				'in the form [iukb: XXXX] with links to the local kb page.'
			);
	    	else return t(
				'Rewrites links to kb.iu.edu links to local links and expands kb links [iukb:XXXX] with a ' .
				'link to the document id XXXX.'
			);
			break;
	}
}

/**
 * Sub: iukb_filter
 * Purpose: workhorse for replacing URLs and [iukb]
 */

function iukb_filter($op, $delta = 0, $format = -1, $text = '') {
	if ($op == 'list') return array(
		0 => t('IUKB Link Translation'),
	);
	switch ($delta) { // delta is the number of the filter we're applying
		case 0: // http://kb.iu.edu/data/XXXX.html -> http://localsite/kb/XXXX
			switch ($op) {
				case 'description':
					return t(
						'Either replace quick kb link formats [iukb:XXXX] or ' .
						'replace actual &lt;a&gt; links to kb.iu.edu in node ' .
						'content.'
					);

				case 'prepare':
					return $text;

				case 'process':
					return _iukb_filter($text, $format);

				case 'settings':
					$form['iukb'] = array(
						'#type' => 'fieldset',
						'#title' => t('IUKB Filter'),
						'#collapsible' => true, '#collapsed' => false,
					);
					$form['iukb']['iukb_encode_kb_link_' . $format] =
						array(
							'#type' => 'radios',
							'#title' =>
								t('Encode &lt;a&gt; links to kb.iu.edu'),
							'#default_value' => variable_get
								('iukb_encode_kb_link_' . $format, 0),
							'#options' => array(
								0 => t('Do not encode links.'),
								1 => t('Encode links to kb.iu.edu to a local page.'),
							),
							'#description' => t(
							  'Whether or not this filter should replace ' .
							  '&lt;a href="http://kb.iu.edu/data/XXXX.html"&gt; links with '.
							  '&lt;a href="http://mysite/kb/XXXX"&gt;.'
							),
						);
					$form['iukb']['iukb_encode_iukb_' . $format] =
						array(
							'#type' => 'radios',
							'#title' => t('Encode [iukb:XXXX]'),
							'#default_value' => variable_get
								  ('iukb_encode_iukb_' . $format, 0),
							'#options' => array(
								0 => t('Do not encode links.'),
								1 => t('Encode quicklink [iukb:XXXX] to a local page.'),
							),
							'#description' => t(
								'Whether or not this filter should replace ' .
								'[iukb:XXXX] with ' .
								'&lt;a href="http://mysite/kb/XXXX"&gt;.'
							),
						);
					return $form;
			}
			break;
	}
}

/**
	iukb_create_update_node is used to create and update local
	knowledgebase nodes
**/

function iukb_create_update_node($docId, $nodeId = NULL) {
		
		if ($nodeId) {
			$iukb_node = node_load($nodeId);
		} else {
			$iukb_node = new stdClass();
			$iukb_node->type = 'iukb';
			$iukb_node->uid = 1;
			$iukb_node->status = 1;
			$iukb_node->promote = 1;
			$iukb_node->revision = 1;
		}

		$iukb_node->title = iukb_get_title($docId);
		$document = iukb_get_document($docId);
		preg_match_all('/\<body\>(.*?)\<\/body\>/s', $document, $body);
		$iukb_node->body = $body[1][0];
		$iukb_node->teaser = iukb_create_teaser($body[1][0], 20);

		node_save($iukb_node);

		return $iukb_node->nid;
}

// The REST functions don't provide teaser text so we're going to create some!
function iukb_create_teaser($body, $limit) {
	$teaser = strip_tags($body);
	if (strlen($teaser) > $limit) {
		$word_array = array_keys(str_word_count($teaser, 2));
		$teaser = substr($teaser, 0, $word_array[$limit]);
	}
	//error_log("Teaser: " . $teaser);
	return $teaser . '...';
}

// Our cron job pulls all the KnowledgeBase doc ids and checks to make sure our local nodes are up-to-date
function iukb_cron() {
	$docIDs = iukb_get_documents();
	foreach ($docIDs as $docId) {
		$updated_datetime = iukb_get_last_updated($docId);
		$query = db_query("SELECT nid, updated_timestamp FROM {iukb_doc_node} WHERE did = '%s'",array($docId));
		$doc_node = db_fetch_object($query);
		if (isset($doc_node->nid)) {
			// if the updated datetime is newer than the node's updated datetime...
			if (strtotime($doc_node->updated_timestamp) < strtotime($updated_datetime)) {	
				$nodeId = iukb_create_update_node($docId, $doc_node->nid);	
				$update_values = array('updated_timestamp' => $updated_datetime, 'nid' => $nodeId);
				drupal_write_record('iukb_doc_node', $update_values, 'nid');
			}
		} else {
			$nodeId = iukb_create_update_node($docId);
			$insert_values = array('updated_timestamp' => $updated_datetime, 'nid' => $nodeId, 'did' => $docId);
			drupal_write_record('iukb_doc_node', $insert_values);
		}		
	}
}

function iukb_get_documents() {
	$request = IUKB_REST_URL . IUKB_KB . '/documents';
	$ch = curl_init($request);
	curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
	curl_setopt($ch, CURLOPT_USERPWD, IUKB_API_USER.':'.IUKB_API_KEY);
	$response = curl_exec($ch);
	$xmlObj = simplexml_load_string($response);
	$docIds = array();
	foreach ($xmlObj->document as $doc) {
		$docIds[] = (string) $doc->id;
	}
	return $docIds;
}

function iukb_get_document($docId) {
	$request = IUKB_REST_URL . IUKB_KB . '/document/' . IUKB_AUDIENCE . '/' . $docId;
	$ch = curl_init($request);
	curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
	curl_setopt($ch, CURLOPT_USERPWD, IUKB_API_USER.':'.IUKB_API_KEY);
	$response = curl_exec($ch);
	//error_log($response);
	return $response;
}

function iukb_get_document_preview($docId) {
	$request = IUKB_REST_URL . IUKB_KB . '/document/preview/' . IUKB_AUDIENCE . '/' . $docId;
	$ch = curl_init($request);
	curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
	curl_setopt($ch, CURLOPT_USERPWD, IUKB_API_USER.':'.IUKB_API_KEY);
	$response = curl_exec($ch);
	error_log($response);
}

function iukb_get_last_updated($docId) {
	$request = IUKB_REST_URL . IUKB_KB . '/document/' . IUKB_AUDIENCE . '/' . $docId;
	$ch = curl_init($request);
	curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
	curl_setopt($ch, CURLOPT_HEADER, TRUE); // header will be at output
	curl_setopt($ch, CURLOPT_NOBODY, TRUE); // header will be at output
	curl_setopt($ch, CURLOPT_USERPWD, IUKB_API_USER.':'.IUKB_API_KEY);
	$response = curl_exec($ch);
	if (preg_match('/X-kb-lastmodified: (.*)/', $response, $matches)) {
		return $matches[1];
	}
}

function iukb_get_title($docId) {
	$request = IUKB_REST_URL . IUKB_KB . '/document/' . IUKB_AUDIENCE . '/' . $docId;
	$ch = curl_init($request);
	curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
	curl_setopt($ch, CURLOPT_HEADER, TRUE); // header will be at output
	curl_setopt($ch, CURLOPT_NOBODY, TRUE); // header will be at output
	curl_setopt($ch, CURLOPT_USERPWD, IUKB_API_USER.':'.IUKB_API_KEY);
	$response = curl_exec($ch);
	if (preg_match('/X-kb-titles-'.IUKB_AUDIENCE.': (.*)/', $response, $matches)) {
		return $matches[1];
	} else if (preg_match('/X-kb-titles-default: (.*)/', $response, $matches)) {
		return $matches[1];
	}
}

function iukb_get_title_alt($docId) {
	$request = IUKB_REST_URL . IUKB_KB . '/document/' . IUKB_AUDIENCE . '/' . $docId;
	$headers = get_headers($request);
	error_log(print_r($headers,1));
	if (preg_match('/X-kb-titles-'.IUKB_AUDIENCE.': (.*)/', $headers, $matches)) {
		return $matches[1];
	} else if (preg_match('/X-kb-titles-default: (.*)/', $headers, $matches)) {
		return $matches[1];
	}
}

function iukb_get_titles($docIds, $concurrency = 15) {
	error_log(count($docIds));
	error_log(date_format(date_create(),'h:i:s'));
	$titles = array();
	$request = IUKB_REST_URL . IUKB_KB . '/document/' . IUKB_AUDIENCE . '/';
	
	while ($i < count($docIds)) {
		$part = array_slice($docIds, $i, $concurrency);
		$mh = curl_multi_init();
		$handles = array();
		foreach ($part as $id) {
			$ch = curl_init($request . $id);
			curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
			curl_setopt($ch, CURLOPT_HEADER, TRUE); // header will be at output
			curl_setopt($ch, CURLOPT_NOBODY, TRUE); // header will be at output
			curl_setopt($ch, CURLOPT_USERPWD, IUKB_API_USER.':'.IUKB_API_KEY);
			
			$handles[$id] = $ch;
			curl_multi_add_handle($mh, $ch);
		}
		
		$active = null;
		//execute the handles
		do {
				$mrc = curl_multi_exec($mh, $active);
		} while ($active > 0);
		
		foreach ($part as $id) {
			$response = curl_multi_getcontent($handles[$id]);
			if (preg_match('/X-kb-titles-'.IUKB_AUDIENCE.': (.*)/', $response, $matches)) {
				$titles[$id] = $matches[1];
			} else if (preg_match('/X-kb-titles-default: (.*)/', $response, $matches)) {
				$titles[$id] = $matches[1];
			}
			curl_multi_remove_handle($mh, $handles[$id]);
		}
		curl_multi_close($mh);
		$i += $concurrency;
	}
	
	$part = array_slice($docIds, $i);
	$mh = curl_multi_init();
	$handles = array();
	foreach ($part as $id) {
		$ch = curl_init($request . $id);
		curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
		curl_setopt($ch, CURLOPT_HEADER, TRUE); // header will be at output
		curl_setopt($ch, CURLOPT_NOBODY, TRUE); // header will be at output
		curl_setopt($ch, CURLOPT_USERPWD, IUKB_API_USER.':'.IUKB_API_KEY);
		
		$handles[$id] = $ch;
		curl_multi_add_handle($mh, $ch);
	}
	
	$active = null;
	//execute the handles
	do {
			$mrc = curl_multi_exec($mh, $active);
	} while ($active > 0);
	
	foreach ($part as $id) {
		$response = curl_multi_getcontent($handles[$id]);
		if (preg_match('/X-kb-titles-'.IUKB_AUDIENCE.': (.*)/', $response, $matches)) {
			$titles[$id] = $matches[1];
		} else if (preg_match('/X-kb-titles-default: (.*)/', $response, $matches)) {
			$titles[$id] = $matches[1];
		}
		curl_multi_remove_handle($mh, $handles[$id]);
	}
	curl_multi_close($mh);
	
	error_log(count($titles));
	error_log(date_format(date_create(),'h:i:s'));
	return $titles;
}

function iukb_soap_document($docId) {
	try {
		$client = new SoapClient(IUKB_SOAP_URL);
		$doc = $client->getDocument(IUKB_API_KEY, array("fgrid-all"), $docId, array("fgrid-all"), IUKB_AUDIENCE);
	} catch (SoapFault $fault) {
		watchdog('iukb', 'Error executing iukb_soap_document for docId @docId.  ' . $fault, array('@docId' => $docId), WATCHDOG_ERROR);
	}
	
	return $doc;
}

/**
 * Sub: iukb_soap_lookup
 * Purpose: Returns HTML to represent the KB article passed in
 *   (menu callback to /kb/XXXX where XXXX is a KB docid)
 */

function iukb_soap_lookup($docId) {
	drupal_add_css(drupal_get_path("module","iukb")."/css/iukb.css");
	if ($docId) {
		$returnDoc = iukb_soap_document($docId);
		if ($returnDoc) {
			$xml_string = $returnDoc->text;
			$xml_string = preg_replace('/<boiler src="fg-credit">(.*)<\/boiler>/s', '', $xml_string);
			$xml_doc = simplexml_load_string($xml_string);
			
			drupal_set_title($xml_doc->kbml->kbq);
			
			$xp = new XsltProcessor();
	
			// create a DOM document and load the XSL stylesheet
			$xsl = new DomDocument;
			$xsl->load(drupal_get_path('module', 'iukb') . '/XSL/kbdoc.xsl');
	
			// import the XSL styelsheet into the XSLT process
			$xp->importStylesheet($xsl);
	
			$html = $xp->transformToXml($xml_doc);
			$html .= drupal_get_form('search_form', NULL, NULL, 'iukb');
		} else {
			$html = "<br/>Document not found.";
		}
	} else {
		$html = "<br/>Invalid Document ID: $docId, please re-enter the Document ID."; 
	}
	return $html;
}

function iukb_search_redirect() {
	$query = array();
	foreach ($_GET as $key => $val) {
		if ($key == 'q') {
			continue;
		}
		else if ($key == 'search') {
			$query['keys'] = $val;
		}
		else {
			$query[$key] = $val;
		}
	}
	drupal_goto('search/iukb', $query);
}

function iukb_soap_get_search_results($query = '', $page_size = NULL, $start_page = NULL) {
	try {
		$client = new SoapClient(IUKB_SOAP_URL);
		$results = $client->doSearch(IUKB_API_KEY, IUKB_KB, $query, 0, array("fgrid-all"), IUKB_AUDIENCE, 0, $start_page, $page_size);
		return $results;
	} catch (SoapFault $fault) {
		watchdog('iukb', 'Error executing iukb_get_search_results.  ' . $fault, array(), WATCHDOG_ERROR);
	}
}

function iukb_get_title_soap($docId) {
	$rval = "";
	if ($returnDoc = iukb_soap_document($docId)) {
		$xml_string = $returnDoc->text;
		$xml_doc = simplexml_load_string($xml_string);		
		$rval = $xml_doc->kbml->kbq;
	} else {
		watchdog('iukb', 'Document @docId not found.', array('@docId' => $docId), WATCHDOG_ERROR);
	}
	return $rval; 
}

function _iukb_filter($text, $format) {
	$patterns = array();
	$replacements = array();
	if (variable_get('iukb_encode_kb_link_' . $format, 0)) {
		$patterns[] = '/href[\s\v]*=[\s\v]*[\'"]https?:\/\/kb.iu.edu\/data\/([a-z]{4})\.html#?([^?\'"]*)[\'"]/ise';
		$replacements[] = "'href=\"' . url('kb/document/$1', array('fragment' => '$2')) . '\"'";
	}
	
	if (variable_get('iukb_encode_iukb_' . $format, 0)) {
		$patterns[] = '/\[\s*iukb\s*\:\s*([a-z]{4})\s*\]/ie'; // [iukb:xxxx]
		$replacements[] = "l(iukb_get_title('$1'), 'kb/document/$1');";
	}
	return preg_replace($patterns, $replacements, $text);
}

function iukb_form_search_form_alter(&$form, &$form_state) {
	if ($form['module']['#value'] == 'iukb') {
		$form['basic']['#title'] = t('Search the Knowledge Base');
	}
}

function iukb_preprocess_search_results(&$vars) {
	$search_results = '';
	foreach ($vars['results'] as $result) {
		if ($result['node']->type == 'iukb') {
			$query = db_query("SELECT DATE_FORMAT(updated_timestamp, '%%m/%%d/%%Y') as updated_timestamp FROM {iukb_doc_node} WHERE nid = '%d'", array($result['node']->nid));
			while ($updated_timestamp = db_fetch_object($query)) {
				$search_results = $search_results . "<dt class='title'>" . l($result['node']->title, "node/" . $result['node']->nid) . "</dt><dd><p class='search-snippet'>" . $result['snippet'] . "</p><p class='search-info'>Knowledge base - " . $updated_timestamp->updated_timestamp . "</p></dd>";
			}
		} else {
			$search_results = $search_results . "<dt class='title'><a href='" . $result['link'] . "'>" . $result['title'] . "</a></dt><dd><p class='search-snippet'>" . $result['snippet'] . "</p><p class='search-info'>" . $result['type'] . " - " . $result['user'] . " - " . date('d/m/Y - H:i', $result['date']) . "</p></dd>";
		} 
	}

	$vars['search_results'] = $search_results;
}

function iukb_search($op = 'search', $keys = NULL) {
	switch ($op) {
		case 'name':
			return t('Knowledge base');
		case 'search':
			$searchResults = do_search($keys, 'node');
			foreach ($searchResults as $result) {
				$nid = $result->sid;
				$query = db_query("SELECT did, UNIX_TIMESTAMP(updated_timestamp) as updated_timestamp FROM {iukb_doc_node} WHERE nid = '%d'",array($nid));
				while ($doc = db_fetch_object($query)) {
					$doc_node = node_load($nid);
					$results[] = array(
						'node' => $doc_node,
						'link' => url("node/".$nid),
						'type' => 'Knowledge base',
						'title' => $doc_node->title,
						'date' => $doc->updated_timestamp,
						'snippet' => search_excerpt($keys, $doc_node->body),
					);
				}
			}
			
			return $results;
	}
}

function iukb_document_list() {
	
	error_log(date_format(date_create(), 'h:i:s'));
	$docIds = iukb_get_documents();
	$titles = array();
	foreach ($docIds as $id) {
		$titles[$id] = iukb_get_title($id);
	}
	error_log(print_r($titles,1));
	error_log(date_format(date_create(), 'h:i:s'));
// 		
// 		$docIds = array();
// 		foreach ($response->documents as $docId) {
// 			if ($title = iukb_get_title($docId)) {
// 				$items[] = l($title, "kb/document/$docId");
// 			}
// 		}
// 		
// 		$rval = theme('item_list', $items);
// 	} catch(SoapFault $fault) {
// 		$rval = "SOAP Issues: $fault";
// 	}
// 	return $rval;
}
