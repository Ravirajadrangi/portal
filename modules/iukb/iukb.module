<?php
// vim: filetype=php
// Author: Matthew Lewallen
// Contact: mlewalle [at] indiana edu -or- mithril293 [at] gmail com

/**
 * @file
 * This module provides several menu callbacks (all beginning with /kb/) and
 * an optional input filter that implement theming kb.iu.edu articles through
 * the local site's theme.
 */
define("IUKB_API_USER", "fgrid");
define("IUKB_API_KEY", "OV93R7JNO0");
define("IUKB_KB", "futuregrid");
define("IUKB_AUDIENCE", "fgrid");
define("IUKB_RESULTS_PER_PAGE", "10");
define("IUKB_SOAP_URL", "http://remote.kb.iu.edu/SOAP/v0.2/kb.wsdl");
define("IUKB_REST_URL", "https://remote.kb.iu.edu/REST/v0.2/");

/**
 * Sub: iukb_help
 * Purpose: Implementation of hook_help
 */

function iukb_help($section) {
	switch ($section) {
		case 'admin/help#iukb':
			return t('<p>The iukb module provides a menu callback to bring content from the IU KB and format it with the current site\'s theme.</p><p>There is also an input filter that will automaticall map a href links from kb.iu.edu to the local site\'s rendering of the page and for a convenience [iukb] link encoding.');
	}
}

/**
 * Sub: iukb_menu
 * Purpose: Implements iukb_menu and defines 3 menu callbacks:
 * kb/%, kb/search/%, kb/search/%/%
 */

function iukb_menu() {

	// Initial search
	$items['kb'] = array(
		'title' => 'Knowledge Base Search',
		'page callback' => 'iukb_search_redirect',
		'access arguments' => array('access iukb'),
		'type' => MENU_CALLBACK,
	);
	$items['kb/index'] = array(
		'title' => 'Knowledge Base Document Index',
		'page callback' => 'iukb_document_list',
		'access arguments' => array('access iukb'),
		'type' => MENU_CALLBACK,
	);
	
	// kb article
	$items['kb/document/%'] = array(
		'title' => 'Knowledge Base',
		'page callback' => 'iukb_soap_lookup',
		'page arguments' => array(2),
		'access arguments' => array('access iukb'),
		'type' => MENU_CALLBACK,
	);
	
	// admin
	$items['admin/settings/iukb'] = array(
		'title' => 'IU Knowledge Base Configuration'
	);
	return $items;
}

/**
 * Sub: iukb_perm
 * Purpose: Implements hook_perm
 * Note: administer iukb isn't yet used
 */

function iukb_perm() {
  return array('administer iukb', 'access iukb');
}

/**
 * Sub: iukb_filter_tips
 * Purpose: implements hook_filter_tips, but I'm not sure what it does yet (:
 */

function iukb_filter_tips($delta, $format, $long = FALSE) {
	switch ($delta) {
		case 0:
			if ($long) return t(
				'This filter searches node content for &lt;a&lt; links to ' .
				'kb.iu.edu and rewrites them to local /kb/ entries which ' .
				'display the same content. It can also replace quick kb links ' .
				'in the form [iukb: XXXX] with links to the local kb page.'
			);
	    	else return t(
				'Rewrites links to kb.iu.edu links to local links and expands kb links [iukb:XXXX] with a ' .
				'link to the document id XXXX.'
			);
			break;
	}
}

/**
 * Sub: iukb_filter
 * Purpose: workhorse for replacing URLs and [iukb]
 */

function iukb_filter($op, $delta = 0, $format = -1, $text = '') {
	if ($op == 'list') return array(
		0 => t('IUKB Link Translation'),
	);
	switch ($delta) { // delta is the number of the filter we're applying
		case 0: // http://kb.iu.edu/data/XXXX.html -> http://localsite/kb/XXXX
			switch ($op) {
				case 'description':
					return t(
						'Either replace quick kb link formats [iukb:XXXX] or ' .
						'replace actual &lt;a&gt; links to kb.iu.edu in node ' .
						'content.'
					);

				case 'prepare':
					return $text;

				case 'process':
					return _iukb_filter($text, $format);

				case 'settings':
					$form['iukb'] = array(
						'#type' => 'fieldset',
						'#title' => t('IUKB Filter'),
						'#collapsible' => true, '#collapsed' => false,
					);
					$form['iukb']['iukb_encode_kb_link_' . $format] =
						array(
							'#type' => 'radios',
							'#title' =>
								t('Encode &lt;a&gt; links to kb.iu.edu'),
							'#default_value' => variable_get
								('iukb_encode_kb_link_' . $format, 0),
							'#options' => array(
								0 => t('Do not encode links.'),
								1 => t('Encode links to kb.iu.edu to a local page.'),
							),
							'#description' => t(
							  'Whether or not this filter should replace ' .
							  '&lt;a href="http://kb.iu.edu/data/XXXX.html"&gt; links with '.
							  '&lt;a href="http://mysite/kb/XXXX"&gt;.'
							),
						);
					$form['iukb']['iukb_encode_iukb_' . $format] =
						array(
							'#type' => 'radios',
							'#title' => t('Encode [iukb:XXXX]'),
							'#default_value' => variable_get
								  ('iukb_encode_iukb_' . $format, 0),
							'#options' => array(
								0 => t('Do not encode links.'),
								1 => t('Encode quicklink [iukb:XXXX] to a local page.'),
							),
							'#description' => t(
								'Whether or not this filter should replace ' .
								'[iukb:XXXX] with ' .
								'&lt;a href="http://mysite/kb/XXXX"&gt;.'
							),
						);
					return $form;
			}
			break;
	}
}

function iukb_get_documents() {
	$request = IUKB_REST_URL . IUKB_KB . '/documents';
	$ch = curl_init($request);
	curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
	curl_setopt($ch, CURLOPT_USERPWD, IUKB_API_USER.':'.IUKB_API_KEY);
	$response = curl_exec($ch);
	$xmlObj = simplexml_load_string($response);
	$docIds = array();
	foreach ($xmlObj->document as $doc) {
		$docIds[] = (string) $doc->id;
	}
	return $docIds;
}

function iukb_get_document($docId) {
	$request = IUKB_REST_URL . IUKB_KB . '/document/' . IUKB_AUDIENCE . '/' . $docId;
	$ch = curl_init($request);
	curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
	curl_setopt($ch, CURLOPT_USERPWD, IUKB_API_USER.':'.IUKB_API_KEY);
	$response = curl_exec($ch);
	error_log($response);
}

function iukb_get_document_preview($docId) {
	$request = IUKB_REST_URL . IUKB_KB . '/document/preview/' . IUKB_AUDIENCE . '/' . $docId;
	$ch = curl_init($request);
	curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
	curl_setopt($ch, CURLOPT_USERPWD, IUKB_API_USER.':'.IUKB_API_KEY);
	$response = curl_exec($ch);
	error_log($response);
}

function iukb_get_title($docId) {
	$request = IUKB_REST_URL . IUKB_KB . '/document/' . IUKB_AUDIENCE . '/' . $docId;
	$ch = curl_init($request);
	curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
	curl_setopt($ch, CURLOPT_HEADER, TRUE); // header will be at output
	curl_setopt($ch, CURLOPT_NOBODY, TRUE); // header will be at output
	curl_setopt($ch, CURLOPT_USERPWD, IUKB_API_USER.':'.IUKB_API_KEY);
	$response = curl_exec($ch);
	if (preg_match('/X-kb-titles-'.IUKB_AUDIENCE.': (.*)/', $response, $matches)) {
		return $matches[1];
	} else if (preg_match('/X-kb-titles-default: (.*)/', $response, $matches)) {
		return $matches[1];
	}
}

function iukb_get_title_alt($docId) {
	$request = IUKB_REST_URL . IUKB_KB . '/document/' . IUKB_AUDIENCE . '/' . $docId;
	$headers = get_headers($request);
	error_log(print_r($headers,1));
	if (preg_match('/X-kb-titles-'.IUKB_AUDIENCE.': (.*)/', $headers, $matches)) {
		return $matches[1];
	} else if (preg_match('/X-kb-titles-default: (.*)/', $headers, $matches)) {
		return $matches[1];
	}
}

function iukb_get_titles($docIds, $concurrency = 15) {
	error_log(count($docIds));
	error_log(date_format(date_create(),'h:i:s'));
	$titles = array();
	$request = IUKB_REST_URL . IUKB_KB . '/document/' . IUKB_AUDIENCE . '/';
	
	while ($i < count($docIds)) {
		$part = array_slice($docIds, $i, $concurrency);
		$mh = curl_multi_init();
		$handles = array();
		foreach ($part as $id) {
			$ch = curl_init($request . $id);
			curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
			curl_setopt($ch, CURLOPT_HEADER, TRUE); // header will be at output
			curl_setopt($ch, CURLOPT_NOBODY, TRUE); // header will be at output
			curl_setopt($ch, CURLOPT_USERPWD, IUKB_API_USER.':'.IUKB_API_KEY);
			
			$handles[$id] = $ch;
			curl_multi_add_handle($mh, $ch);
		}
		
		$active = null;
		//execute the handles
		do {
				$mrc = curl_multi_exec($mh, $active);
		} while ($active > 0);
		
		foreach ($part as $id) {
			$response = curl_multi_getcontent($handles[$id]);
			if (preg_match('/X-kb-titles-'.IUKB_AUDIENCE.': (.*)/', $response, $matches)) {
				$titles[$id] = $matches[1];
			} else if (preg_match('/X-kb-titles-default: (.*)/', $response, $matches)) {
				$titles[$id] = $matches[1];
			}
			curl_multi_remove_handle($mh, $handles[$id]);
		}
		curl_multi_close($mh);
		$i += $concurrency;
	}
	
	$part = array_slice($docIds, $i);
	$mh = curl_multi_init();
	$handles = array();
	foreach ($part as $id) {
		$ch = curl_init($request . $id);
		curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
		curl_setopt($ch, CURLOPT_HEADER, TRUE); // header will be at output
		curl_setopt($ch, CURLOPT_NOBODY, TRUE); // header will be at output
		curl_setopt($ch, CURLOPT_USERPWD, IUKB_API_USER.':'.IUKB_API_KEY);
		
		$handles[$id] = $ch;
		curl_multi_add_handle($mh, $ch);
	}
	
	$active = null;
	//execute the handles
	do {
			$mrc = curl_multi_exec($mh, $active);
	} while ($active > 0);
	
	foreach ($part as $id) {
		$response = curl_multi_getcontent($handles[$id]);
		if (preg_match('/X-kb-titles-'.IUKB_AUDIENCE.': (.*)/', $response, $matches)) {
			$titles[$id] = $matches[1];
		} else if (preg_match('/X-kb-titles-default: (.*)/', $response, $matches)) {
			$titles[$id] = $matches[1];
		}
		curl_multi_remove_handle($mh, $handles[$id]);
	}
	curl_multi_close($mh);
	
	error_log(count($titles));
	error_log(date_format(date_create(),'h:i:s'));
	return $titles;
}

function iukb_soap_document($docId) {
	try {
		$client = new SoapClient(IUKB_SOAP_URL);
		$doc = $client->getDocument(IUKB_API_KEY, array("fgrid-all"), $docId, array("fgrid-all"), IUKB_AUDIENCE);
	} catch (SoapFault $fault) {
		watchdog('iukb', 'Error executing iukb_soap_document for docId @docId.  ' . $fault, array('@docId' => $docId), WATCHDOG_ERROR);
	}
	
	return $doc;
}

/**
 * Sub: iukb_soap_lookup
 * Purpose: Returns HTML to represent the KB article passed in
 *   (menu callback to /kb/XXXX where XXXX is a KB docid)
 */

function iukb_soap_lookup($docId) {
	drupal_add_css(drupal_get_path("module","iukb")."/css/iukb.css");
	if ($docId) {
		$returnDoc = iukb_soap_document($docId);
		if ($returnDoc) {
			$xml_string = $returnDoc->text;
			$xml_string = preg_replace('/<boiler src="fg-credit">(.*)<\/boiler>/s', '', $xml_string);
			$xml_doc = simplexml_load_string($xml_string);
			
			drupal_set_title($xml_doc->kbml->kbq);
			
			$xp = new XsltProcessor();
	
			// create a DOM document and load the XSL stylesheet
			$xsl = new DomDocument;
			$xsl->load(drupal_get_path('module', 'iukb') . '/XSL/kbdoc.xsl');
	
			// import the XSL styelsheet into the XSLT process
			$xp->importStylesheet($xsl);
	
			$html = $xp->transformToXml($xml_doc);
			$html .= drupal_get_form('search_form', NULL, NULL, 'iukb');
		} else {
			$html = "<br/>Document not found.";
		}
	} else {
		$html = "<br/>Invalid Document ID: $docId, please re-enter the Document ID."; 
	}
	return $html;
}

function iukb_search_redirect() {
	$query = array();
	foreach ($_GET as $key => $val) {
		if ($key == 'q') {
			continue;
		}
		else if ($key == 'search') {
			$query['keys'] = $val;
		}
		else {
			$query[$key] = $val;
		}
	}
	drupal_goto('search/iukb', $query);
}

function iukb_soap_get_search_results($query = '', $page_size = NULL, $start_page = NULL) {
	try {
		$client = new SoapClient(IUKB_SOAP_URL);
		$results = $client->doSearch(IUKB_API_KEY, IUKB_KB, $query, 0, array("fgrid-all"), IUKB_AUDIENCE, 0, $start_page, $page_size);
		return $results;
	} catch (SoapFault $fault) {
		watchdog('iukb', 'Error executing iukb_get_search_results.  ' . $fault, array(), WATCHDOG_ERROR);
	}
}

function iukb_get_title_soap($docId) {
	$rval = "";
	if ($returnDoc = iukb_soap_document($docId)) {
		$xml_string = $returnDoc->text;
		$xml_doc = simplexml_load_string($xml_string);		
		$rval = $xml_doc->kbml->kbq;
	} else {
		watchdog('iukb', 'Document @docId not found.', array('@docId' => $docId), WATCHDOG_ERROR);
	}
	return $rval; 
}

function _iukb_filter($text, $format) {
	$patterns = array();
	$replacements = array();
	if (variable_get('iukb_encode_kb_link_' . $format, 0)) {
		$patterns[] = '/href[\s\v]*=[\s\v]*[\'"]https?:\/\/kb.iu.edu\/data\/([a-z]{4})\.html#?([^?\'"]*)[\'"]/ise';
		$replacements[] = "'href=\"' . url('kb/document/$1', array('fragment' => '$2')) . '\"'";
	}
	
	if (variable_get('iukb_encode_iukb_' . $format, 0)) {
		$patterns[] = '/\[\s*iukb\s*\:\s*([a-z]{4})\s*\]/ie'; // [iukb:xxxx]
		$replacements[] = "l(iukb_get_title('$1'), 'kb/document/$1');";
	}
	return preg_replace($patterns, $replacements, $text);
}

function iukb_form_search_form_alter(&$form, &$form_state) {
	if ($form['module']['#value'] == 'iukb') {
		$form['basic']['#title'] = t('Search the Knowledge Base');
	}
}

function iukb_search($op = 'search', $keys = NULL) {
	switch ($op) {
		case 'name':
			return t('Knowledge base');
		case 'search':
			global $pager_page_array, $pager_total, $pager_total_items;
			$page = isset($_GET['page']) ? $_GET['page'] : 0;
			$soapResults = iukb_soap_get_search_results($keys, IUKB_RESULTS_PER_PAGE, $page * IUKB_RESULTS_PER_PAGE + 1);
			
			// Convert comma-separated $page to an array, used by other functions.
			$element = 0;
			$pager_page_array = explode(',', $page);
		
			// We calculate the total of pages as ceil(items / limit).
			$pager_total_items[$element] = $soapResults->numResults;
			$pager_total[$element] = ceil($pager_total_items[$element] / IUKB_RESULTS_PER_PAGE);
			$pager_page_array[$element] = max(0, min((int) $pager_page_array[$element], ((int) $pager_total[$element]) - 1));
			
			$results = array();
			$numResults = count($soapResults->documents);
			for ($i = 0; $i < $numResults; $i++) {
				$title = $soapResults->titles[$i];
				$docId = $soapResults->documents[$i];
				$doc = iukb_soap_document($docId);				
				$xml = simplexml_load_string($doc->text);
				$xp = new XsltProcessor();
				$xsl = new DomDocument;
				$xsl->load(drupal_get_path('module', 'iukb') . '/XSL/kbdoc.xsl');
				$xp->importStylesheet($xsl);
				$html = $xp->transformToXml($xml);
				$timestamp = strtotime($xml->metadata->lastmodified['year'].'-'.$xml->metadata->lastmodified['month'].'-'.$xml->metadata->lastmodified['day']);
				
				$results[] = array(
					'link' => url("kb/document/".$soapResults->documents[$i]),
					'type' => 'Knowledge base',
					'title' => htmlspecialchars_decode($soapResults->titles[$i]), // this gets fixed later
					'date' => $timestamp,
					//'extra' => array(),
					'snippet' => search_excerpt($keys, $html),
				);
			}
			
			return $results;
	}
}

function iukb_document_list() {
	
	error_log(date_format(date_create(), 'h:i:s'));
	$docIds = iukb_get_documents();
	$titles = array();
	foreach ($docIds as $id) {
		$titles[$id] = iukb_get_title($id);
	}
	error_log(print_r($titles,1));
	error_log(date_format(date_create(), 'h:i:s'));
// 		
// 		$docIds = array();
// 		foreach ($response->documents as $docId) {
// 			if ($title = iukb_get_title($docId)) {
// 				$items[] = l($title, "kb/document/$docId");
// 			}
// 		}
// 		
// 		$rval = theme('item_list', $items);
// 	} catch(SoapFault $fault) {
// 		$rval = "SOAP Issues: $fault";
// 	}
// 	return $rval;
}
